// Practice OO
// Object oriented programming can be a hard technique to demonstrate, especially to people used to writing smallish
// programs (say Python scripts). In my experience, code that achieves enough complexity to make OO really worthwhile
// is easily 150 to 200 lines (recent examples being a hotkey training program and a C# line counter with nasty
// persistent bugs till I rewrote critical sections with OO). Possibly OO could be done in shorter code and that I
// simply have not had the originality yet to think of a proper assignment. However, below example should be reasonably
// simple to try to get a taste of the power of Object Orientation!

Miniature Offline Role Playing Game

Make a game with a player.
The player is has 50 hitpoints

There is an orc, which has 20 hitpoints

1. Implement the player and the orc. Hint: you could make a class "Character", and create one of each in the main
program

2. We want them to be able to fight: we equip both of them with a weapon. Give the player a sword which does 1d6
(1/2/3/4/5/6) points of damage each round, and the orc an axe which does 1d3 damage each round (1/2/3). Hint: you could
make a 'weapon' class. Whether you subclass it to Axe and Sword subclasses is up to you. Make a method "hit" in the
Player/Character/class that takes a target as argument. Like: player.hits(orc), the target taking damage dependent
on the other's weapon. You could also add a 'getWounded' method.

3. Of course, we also want to SEE (ehm... read) some action: add code to display when someone does damage or gets
wounded (like 'Player swings his sword and does 6 damage to orc' / 'orc gets hit by Player and drops to 14 hitpoints'
Now let the player hit the orc. Then let the orc hit the player.

4. Of course, as things stand, player and orc can keep bashing each other into infinity. Make it so that when any
character takes damage that reduces them to (or below) 0 hit points, a message is shows that the character dies.
Any loop can end by checking the "isAlive()" property. Also note that a dead character cannot hit back.

// you should now have at least two classes and about 50 lines of code.
// So far you have perhaps seen the usefulness of bundling data with methods, but clearly there was little true OO
// behavior: after all, Player and orc only differed in field values (hit points, weapon type, and name) but not in
// behavior. However, you may already see some reasons for that to change, for example that
// "Player gets hit by orc and drops to 37 hit points!" and "orc hits Player with his axe for 1 hit points!" is not
// really proper English. But we can fix that!

5. Let's first make everything proper English. Obviously, there are player characters with names (that start with a
capital letter) and monster characters that only have a species (they of course may have names for their friends and
family, but we dungeoneering heroes don't care about that stuff). Let's make two subclasses of Character, namely Player
and Creature. Then we will make Character abstract, to ensure only a useful being can be made.

6. This is better. It would be nice though if all sentences would start with capital letters. Let's make a utility
class World with a static method message that capitalizes the first letter of each sentence. Replace the
System.out.printlns by the World.message (except in the World class, of course!)

7. Of course, a player may be called something like "Carl", and an orc will be "the orc". Lets do two things: let make
the constructor of Player and Creature throw an exception if they don't start with an uppercase and lowercase,
respectively. Second, let's change the getName() function to return "the " + name in the case of a creature. Also,
I'm only noticing now that Character is also a Java class-better rename it to Being?

// All right: you have some inheritance now, an abstract class, and a utility class. And you should have about 100 lines
// of code now. Of course, the inheritance seems yet trivial -why not set a boolean isMonster to decide whether to
// put 'the' in front of the name? However, inheritance (and the game) becomes much more interesting once classes
// don't simply have different data, but also different behaviors...

8. Enemies may have abilities. For example, if the orc's health drops to 30% or lower, he will enrage, doubling his
damage. So that you do not put things in Creature class that will not other creatures, make a new class Orc, and two
other classes (Kobold and Zombie - for later purposes). Anyway, define the Orc, Kobold and Zombie classes, copy the
hit-method to the Orc class, giving it the annotation @Override to indicate that it overrides the original, and adjust
the code to work (for example by checking that hitPoints is protected, not private). Orc also needs to get a
maxHitPoints to check for the enrage condition. Perhaps also override getName to print "the enraged orc hits..."
And don't forget (like I did) to change the new Creature() to new Orc()...

9. Of course, the output can be nicer; it would be nicer if the orc gives some indication of when it enrages (fix that!)

10. As I'm getting more types of enemies now, it may be the time to make a new package (in this case a
net.ericwubbo.morpg.creature package) to house the creature, orc, kobold and zombie. I do need to make the World.message
method public, but then it runs again.

11. Since I was bitten by the bug of forgetting to rename new Creature to new Orc, I want to avoid such mistakes in the
future. I make the Creature class abstract, so I can't use new Creature(...) anymore, and let the orc constructor
not require the string "orc" anymore- I just pass that to the Creature constructor.

// So this is the first behavior, with some @Override and some abstract. You should have about 150 lines of code now,
// but we can still go deeper. Likely (like me), you've copy-pasted methods from the Creature class to Orc; let's now
// try make this more maintainable and shorter.



